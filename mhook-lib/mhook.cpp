//Copyright (c) 2007-2008, Marton Anka
//
//Permission is hereby granted, free of charge, to any person obtaining a 
//copy of this software and associated documentation files (the "Software"), 
//to deal in the Software without restriction, including without limitation 
//the rights to use, copy, modify, merge, publish, distribute, sublicense, 
//and/or sell copies of the Software, and to permit persons to whom the 
//Software is furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included 
//in all copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
//THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
//IN THE SOFTWARE.

#include <windows.h>
#include <tlhelp32.h>
#include <stdio.h>
#include "mhook.h"
#include "mhook_internal.h"
#include "mhook_thread.h"
#include "../disasm-lib/disasm.h"
#include "mhook_printf.h"

//=========================================================================
#ifndef cntof
#define cntof(a) (sizeof(a)/sizeof(a[0]))
#endif

//=========================================================================
// Global vars
static BOOL g_bVarsInitialized = FALSE;
static CRITICAL_SECTION g_cs;
static MHOOKS_TRAMPOLINE* g_pHooks[MHOOKS_MAX_SUPPORTED_HOOKS];
static DWORD g_nHooksInUse = 0;
static PAGE_INFO* g_pPagesCache[MHOOKS_MAX_SUPPORTED_HOOKS];
static DWORD g_PageSize = 0;
static DWORD g_TramplinesInPage = 0;
#define MHOOK_JMPSIZE 5
//=========================================================================
static VOID EnterCritSec() {
	if (!g_bVarsInitialized) {
		InitializeCriticalSection(&g_cs);
		ZeroMemory(g_pHooks, sizeof(g_pHooks));
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        g_PageSize = si.dwPageSize;
        g_TramplinesInPage = (g_PageSize / sizeof(MHOOKS_TRAMPOLINE)) - 1;
        ZeroMemory(g_pPagesCache, sizeof(g_pPagesCache));
        ODPRINTF((L"mhooks: Mhook_SetHook(first call): page size %d, trampline size %d, tramplines in page %d"
            , g_PageSize
            , sizeof(MHOOKS_TRAMPOLINE)
            , g_TramplinesInPage));

		g_bVarsInitialized = TRUE;
	}
	EnterCriticalSection(&g_cs);
}

//=========================================================================
static VOID LeaveCritSec() {
	LeaveCriticalSection(&g_cs);
}

//=========================================================================
// Internal function:
// 
// Skip over jumps that lead to the real function. Gets around import
// jump tables, etc.
//=========================================================================
static PBYTE SkipJumps(PBYTE pbCode) {
	PBYTE pbOrgCode = pbCode;
#ifdef _M_IX86_X64
#ifdef _M_IX86
	//mov edi,edi: hot patch point
	if (pbCode[0] == 0x8b && pbCode[1] == 0xff)
		pbCode += 2;
	// push ebp; mov ebp, esp; pop ebp;
	// "collapsed" stackframe generated by MSVC
	if (pbCode[0] == 0x55 && pbCode[1] == 0x8b && pbCode[2] == 0xec && pbCode[3] == 0x5d)
		pbCode += 4;
#endif	
	if (pbCode[0] == 0xff && pbCode[1] == 0x25) {
#ifdef _M_IX86
		// on x86 we have an absolute pointer...
		PBYTE pbTarget = *(PBYTE *)&pbCode[2];
		// ... that shows us an absolute pointer.
		return SkipJumps(*(PBYTE *)pbTarget);
#elif defined _M_X64
		// on x64 we have a 32-bit offset...
		INT32 lOffset = *(INT32 *)&pbCode[2];
		// ... that shows us an absolute pointer
		return SkipJumps(*(PBYTE*)(pbCode + 6 + lOffset));
	} else if (pbCode[0] == 0x48 && pbCode[1] == 0xff && pbCode[2] == 0x25) {
		// or we can have the same with a REX prefix
		INT32 lOffset = *(INT32 *)&pbCode[3];
		// ... that shows us an absolute pointer
		return SkipJumps(*(PBYTE*)(pbCode + 7 + lOffset));
#endif
	} else if (pbCode[0] == 0xe9) {
		// here the behavior is identical, we have...
		// ...a 32-bit offset to the destination.
		return SkipJumps(pbCode + 5 + *(INT32 *)&pbCode[1]);
	} else if (pbCode[0] == 0xeb) {
		// and finally an 8-bit offset to the destination
		return SkipJumps(pbCode + 2 + *(CHAR *)&pbCode[1]);
	}
#else
#error unsupported platform
#endif
	return pbOrgCode;
}

//=========================================================================
// Internal function:
//
// Writes code at pbCode that jumps to pbJumpTo. Will attempt to do this
// in as few bytes as possible. Important on x64 where the long jump
// (0xff 0x25 ....) can take up 14 bytes.
//=========================================================================
static PBYTE EmitJump(PBYTE pbCode, PBYTE pbJumpTo) {
#ifdef _M_IX86_X64
	PBYTE pbJumpFrom = pbCode + 5;
	SIZE_T cbDiff = pbJumpFrom > pbJumpTo ? pbJumpFrom - pbJumpTo : pbJumpTo - pbJumpFrom;
	ODPRINTF((L"mhooks: EmitJump: Jumping from %p to %p, diff is %p", pbJumpFrom, pbJumpTo, cbDiff));
	if (cbDiff <= 0x7fff0000) {
		pbCode[0] = 0xe9;
		pbCode += 1;
		*((PDWORD)pbCode) = (DWORD)(DWORD_PTR)(pbJumpTo - pbJumpFrom);
		pbCode += sizeof(DWORD);
	} else {
		pbCode[0] = 0xff;
		pbCode[1] = 0x25;
		pbCode += 2;
#ifdef _M_IX86
		// on x86 we write an absolute address (just behind the instruction)
		*((PDWORD)pbCode) = (DWORD)(DWORD_PTR)(pbCode + sizeof(DWORD));
#elif defined _M_X64
		// on x64 we write the relative address of the same location
		*((PDWORD)pbCode) = (DWORD)0;
#endif
		pbCode += sizeof(DWORD);
		*((PDWORD_PTR)pbCode) = (DWORD_PTR)(pbJumpTo);
		pbCode += sizeof(DWORD_PTR);
	}
#else 
#error unsupported platform
#endif
	return pbCode;
}


//=========================================================================
// Internal function:
//
// Round down to the next multiple of rndDown
//=========================================================================
static MHOOKS_TRAMPOLINE* TrampolineAllocInCache(PBYTE pLower, PBYTE pUpper)
{
    for (int pageIndex = 0; pageIndex < MHOOKS_MAX_SUPPORTED_HOOKS; ++pageIndex)
    {
        if (NULL == g_pPagesCache[pageIndex])
        {
            continue;
        }

        PBYTE pageAddr = (PBYTE)g_pPagesCache[pageIndex];

        if (pLower <= pageAddr && pageAddr < pUpper)
        {
            PAGE_INFO* pi = g_pPagesCache[pageIndex];
            if (pi->counter == g_TramplinesInPage)
            {
                continue;
            }

            ODPRINTF((L"mhooks: Found page in cache: Page address %p, counter %d", pageAddr, pi->counter));

            for (DWORD tramplineIndex = 0; tramplineIndex < g_TramplinesInPage; ++tramplineIndex)
            {
                if (NULL != pi->pTramplines[tramplineIndex].pSystemFunction || pi->pTramplines[tramplineIndex].reserved != FALSE)
                {
                    continue;
		}
				
                DWORD oldProtect = 0;
                VirtualProtect(pi, g_PageSize, PAGE_EXECUTE_READWRITE, &oldProtect);
	
                MHOOKS_TRAMPOLINE* pTrampoline = &pi->pTramplines[tramplineIndex];
                pTrampoline->pPageInfo = pi;
                pTrampoline->reserved = TRUE;
                pi->counter += 1;

                VirtualProtect(pi, g_PageSize, oldProtect, &oldProtect);

                ODPRINTF((L"mhooks: Found free trampline in page: Page address %p, counter %d, trampline addr %p"
                    , pageAddr, pi->counter, pTrampoline));

                return pTrampoline;
            }
		}
	}

	return NULL;
}

//=========================================================================
// Internal function:
//
// Will try to allocate the trampoline structure within 2 gigabytes of
// the target function. 
//=========================================================================
static MHOOKS_TRAMPOLINE* TrampolineAlloc(PBYTE pSystemFunction, S64 nLimitUp, S64 nLimitDown) {

	MHOOKS_TRAMPOLINE* pTrampoline = NULL;

    // do we have room to store this guy?
    if (g_nHooksInUse < MHOOKS_MAX_SUPPORTED_HOOKS) {

	// determine lower and upper bounds for the allocation locations.
	// in the basic scenario this is +/- 2GB but IP-relative instructions
	// found in the original code may require a smaller window.
	PBYTE pLower = pSystemFunction + nLimitUp;
	pLower = pLower < (PBYTE)(DWORD_PTR)0x0000000080000000 ? 
						(PBYTE)(0x1) : (PBYTE)(pLower - (PBYTE)0x7fff0000);
	PBYTE pUpper = pSystemFunction + nLimitDown;
	pUpper = pUpper < (PBYTE)(DWORD_PTR)0xffffffff80000000 ? 
		(PBYTE)(pUpper + (DWORD_PTR)0x7ff80000) : (PBYTE)(DWORD_PTR)0xfffffffffff80000;
	ODPRINTF((L"mhooks: TrampolineAlloc: Allocating for %p between %p and %p", pSystemFunction, pLower, pUpper));

        pTrampoline = TrampolineAllocInCache(pLower, pUpper);

        if (NULL == pTrampoline)
        {
            SYSTEM_INFO sSysInfo = { 0 };
            ::GetSystemInfo(&sSysInfo);

            // go through the available memory blocks and try to allocate a chunk for us
            for (PBYTE pbAlloc = pLower; pbAlloc < pUpper;) {
                // determine current state
                MEMORY_BASIC_INFORMATION mbi;
                ODPRINTF((L"mhooks: TrampolineAlloc: Looking at address %p", pbAlloc));
                if (!VirtualQuery(pbAlloc, &mbi, sizeof(mbi)))
                    break;
                // free & large enough?
                if (mbi.State == MEM_FREE && mbi.RegionSize >= g_PageSize && mbi.RegionSize >= sSysInfo.dwAllocationGranularity) {
                    // yes, align the pointer to the 64K boundary first
                    pbAlloc = (PBYTE)(ULONG_PTR((ULONG_PTR(pbAlloc) + (sSysInfo.dwAllocationGranularity - 1)) / sSysInfo.dwAllocationGranularity) * sSysInfo.dwAllocationGranularity);
                    // and then try to allocate it

                    PAGE_INFO *pageInfo = (PAGE_INFO*)VirtualAlloc(pbAlloc, g_PageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
                    if (!pageInfo)
                    {
                        continue;
                    }

                    pTrampoline = &pageInfo->pTramplines[0];
                    pTrampoline->pPageInfo = pageInfo;
                    pTrampoline->reserved = TRUE;
                    pageInfo->counter = 1;
                    ODPRINTF((L"mhooks: TrampolineAlloc: Allocated block at %p as the trampoline", pTrampoline));

                    DWORD oldProtect = 0;
                    VirtualProtect(pageInfo, g_PageSize, PAGE_EXECUTE_READ, &oldProtect);

                    for (int i = 0; i < MHOOKS_MAX_SUPPORTED_HOOKS; ++i)
                    {
                        if (NULL == g_pPagesCache[i])
                        {
                            g_pPagesCache[i] = pageInfo;
                            break;
                        }
                    }
                    break;
                }
                // continue the search
                pbAlloc = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
            }
	}

	// found and allocated a trampoline?
	if (pTrampoline) {
            // put it into our list so we know we'll have to free it
            for (DWORD i = 0; i < MHOOKS_MAX_SUPPORTED_HOOKS; i++) {
                if (g_pHooks[i] == NULL) {
                    g_pHooks[i] = pTrampoline;
                    g_nHooksInUse++;
                    break;
                }
            }
        }
	}

	return pTrampoline;
}

//=========================================================================
// Internal function:
//
// Return the internal trampoline structure that belongs to a hooked function.
//=========================================================================
static MHOOKS_TRAMPOLINE* TrampolineGet(PBYTE pHookedFunction) {
	for (DWORD i=0; i<MHOOKS_MAX_SUPPORTED_HOOKS; i++) {
		if (g_pHooks[i]) {
			if (g_pHooks[i]->codeTrampoline == pHookedFunction)
				return g_pHooks[i];
		}
	}

	return NULL;
}

//=========================================================================
// Internal function:
//
// Free a trampoline structure.
//=========================================================================
static VOID TrampolineFree(MHOOKS_TRAMPOLINE* pTrampoline, BOOL bNeverUsed) {
	for (DWORD i=0; i<MHOOKS_MAX_SUPPORTED_HOOKS; i++) {
		if (g_pHooks[i] == pTrampoline) {
			g_pHooks[i] = NULL;
			// It might be OK to call VirtualFree, but quite possibly it isn't: 
			// If a thread has some of our trampoline code on its stack
			// and we yank the region from underneath it then it will
			// surely crash upon returning. So instead of freeing the 
			// memory we just let it leak. Ugly, but safe.
			if (bNeverUsed)
            {
                PAGE_INFO * pi = pTrampoline->pPageInfo;

                DWORD oldProtect = 0;
                VirtualProtect(pi, g_PageSize, PAGE_EXECUTE_READWRITE, &oldProtect);
                pi->counter -= 1;
                VirtualProtect(pi, g_PageSize, oldProtect, &oldProtect);

                if (0 == pi->counter)
                {
                    for (int i = 0; i < MHOOKS_MAX_SUPPORTED_HOOKS; ++i)
                    {
                        if (g_pPagesCache[i] == pi)
                        {
                            g_pPagesCache[i] = NULL;
						break;
						}
					}
	                VirtualFree(pi, 0, MEM_RELEASE);
				}
	            else
	            {
	                ZeroMemory(pTrampoline, sizeof(MHOOKS_TRAMPOLINE));
				}
			}
			g_nHooksInUse--;
			break;
		}
	}
}

//=========================================================================
// if IP-relative addressing has been detected, fix up the code so the
// offset points to the original location
static void FixupIPRelativeAddressing(PBYTE pbNew, PBYTE pbOriginal, MHOOKS_PATCHDATA* pdata)
{
#if defined _M_X64
	S64 diff = pbNew - pbOriginal;
	for (DWORD i = 0; i < pdata->nRipCnt; i++) {
		DWORD dwNewDisplacement = (DWORD)(pdata->rips[i].nDisplacement - diff);
		ODPRINTF((L"mhooks: fixing up RIP instruction operand for code at 0x%p: "
			L"old displacement: 0x%8.8x, new displacement: 0x%8.8x", 
			pbNew + pdata->rips[i].dwOffset, 
			(DWORD)pdata->rips[i].nDisplacement, 
			dwNewDisplacement));
		*(PDWORD)(pbNew + pdata->rips[i].dwOffset) = dwNewDisplacement;
	}
#endif
}

//=========================================================================
// Examine the machine code at the target function's entry point, and
// skip bytes in a way that we'll always end on an instruction boundary.
// We also detect branches and subroutine calls (as well as returns)
// at which point disassembly must stop.
// Finally, detect and collect information on IP-relative instructions
// that we can patch.
static DWORD DisassembleAndSkip(PVOID pFunction, DWORD dwMinLen, MHOOKS_PATCHDATA* pdata) {
	DWORD dwRet = 0;
	pdata->nLimitDown = 0;
	pdata->nLimitUp = 0;
	pdata->nRipCnt = 0;
#ifdef _M_IX86
	ARCHITECTURE_TYPE arch = ARCH_X86;
#elif defined _M_X64
	ARCHITECTURE_TYPE arch = ARCH_X64;
#else
	#error unsupported platform
#endif
	DISASSEMBLER dis;
	if (InitDisassembler(&dis, arch)) {
		INSTRUCTION* pins = NULL;
		U8* pLoc = (U8*)pFunction;
		DWORD dwFlags = DISASM_DECODE | DISASM_DISASSEMBLE | DISASM_ALIGNOUTPUT;

		ODPRINTF((L"mhooks: DisassembleAndSkip: Disassembling %p", pLoc));
		while ( (dwRet < dwMinLen) && (pins = GetInstruction(&dis, (ULONG_PTR)pLoc, pLoc, dwFlags)) ) {
			ODPRINTF(("mhooks: DisassembleAndSkip: %p:(0x%2.2x) %s", pLoc, pins->Length, pins->String));
			if (pins->Type == ITYPE_RET		) break;
			if (pins->Type == ITYPE_BRANCH	) break;
			if (pins->Type == ITYPE_BRANCHCC) break;
			if (pins->Type == ITYPE_CALL	) break;
			if (pins->Type == ITYPE_CALLCC	) break;

			#if defined _M_X64
				BOOL bProcessRip = FALSE;
				// mov or lea to register from rip+imm32
				if ((pins->Type == ITYPE_MOV || pins->Type == ITYPE_LEA) && (pins->X86.Relative) && 
					(pins->X86.OperandSize == 8) && (pins->OperandCount == 2) &&
					(pins->Operands[1].Flags & OP_IPREL) && (pins->Operands[1].Register == AMD64_REG_RIP))
				{
					// rip-addressing "mov reg, [rip+imm32]"
					ODPRINTF((L"mhooks: DisassembleAndSkip: found OP_IPREL on operand %d with displacement 0x%x (in memory: 0x%x)", 1, pins->X86.Displacement, *(PDWORD)(pLoc+3)));
					bProcessRip = TRUE;
				}
				// mov or lea to rip+imm32 from register
				else if ((pins->Type == ITYPE_MOV || pins->Type == ITYPE_LEA) && (pins->X86.Relative) && 
					(pins->X86.OperandSize == 8) && (pins->OperandCount == 2) &&
					(pins->Operands[0].Flags & OP_IPREL) && (pins->Operands[0].Register == AMD64_REG_RIP))
				{
					// rip-addressing "mov [rip+imm32], reg"
					ODPRINTF((L"mhooks: DisassembleAndSkip: found OP_IPREL on operand %d with displacement 0x%x (in memory: 0x%x)", 0, pins->X86.Displacement, *(PDWORD)(pLoc+3)));
					bProcessRip = TRUE;
				}
				else if ( (pins->OperandCount >= 1) && (pins->Operands[0].Flags & OP_IPREL) )
				{
					// unsupported rip-addressing
					ODPRINTF((L"mhooks: DisassembleAndSkip: found unsupported OP_IPREL on operand %d", 0));
					// dump instruction bytes to the debug output
					for (DWORD i=0; i<pins->Length; i++) {
						ODPRINTF((L"mhooks: DisassembleAndSkip: instr byte %2.2d: 0x%2.2x", i, pLoc[i]));
					}
					break;
				}
				else if ( (pins->OperandCount >= 2) && (pins->Operands[1].Flags & OP_IPREL) )
				{
					// unsupported rip-addressing
					ODPRINTF((L"mhooks: DisassembleAndSkip: found unsupported OP_IPREL on operand %d", 1));
					// dump instruction bytes to the debug output
					for (DWORD i=0; i<pins->Length; i++) {
						ODPRINTF((L"mhooks: DisassembleAndSkip: instr byte %2.2d: 0x%2.2x", i, pLoc[i]));
					}
					break;
				}
				else if ( (pins->OperandCount >= 3) && (pins->Operands[2].Flags & OP_IPREL) )
				{
					// unsupported rip-addressing
					ODPRINTF((L"mhooks: DisassembleAndSkip: found unsupported OP_IPREL on operand %d", 2));
					// dump instruction bytes to the debug output
					for (DWORD i=0; i<pins->Length; i++) {
						ODPRINTF((L"mhooks: DisassembleAndSkip: instr byte %2.2d: 0x%2.2x", i, pLoc[i]));
					}
					break;
				}
				// follow through with RIP-processing if needed
				if (bProcessRip) {
					// calculate displacement relative to function start
					S64 nAdjustedDisplacement = pins->X86.Displacement + (pLoc - (U8*)pFunction);
					// store displacement values furthest from zero (both positive and negative)
					if (nAdjustedDisplacement < pdata->nLimitDown)
						pdata->nLimitDown = nAdjustedDisplacement;
					if (nAdjustedDisplacement > pdata->nLimitUp)
						pdata->nLimitUp = nAdjustedDisplacement;
					// store patch info
					if (pdata->nRipCnt < MHOOKS_MAX_RIPS) {
						pdata->rips[pdata->nRipCnt].dwOffset = dwRet + 3;
						pdata->rips[pdata->nRipCnt].nDisplacement = pins->X86.Displacement;
						pdata->nRipCnt++;
					} else {
						// no room for patch info, stop disassembly
						break;
					}
				}
			#endif

			dwRet += pins->Length;
			pLoc  += pins->Length;
		}

		CloseDisassembler(&dis);
	}

	return dwRet;
}

static BOOL FindSystemFunction(HOOK_CONTEXT* hookCtx, int fromIdx, int toIdx, PVOID pSystemFunction)
{
    for (int idx = fromIdx; idx < toIdx; idx++)
    {
        if (hookCtx[idx].pSystemFunction == pSystemFunction)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=========================================================================
// code is based on the Mhook_SetHook
void Mhook_SetHookEx(HOOK_INFO* hooks, int hookCount)
{
    INT nOriginalPriority = 0;

    HOOK_CONTEXT* hookCtx = (HOOK_CONTEXT*)malloc(hookCount * sizeof(HOOK_CONTEXT));

    if (hookCtx == NULL)
    {
        // return error status

        for (int idx = 0; idx < hookCount; idx++)
        {
            hooks[idx].hookStatus = MHOOK_HOOK_FAILED;
        }

        return;
    }

	EnterCritSec();

    for (int idx = 0; idx < hookCount; idx++)
    {
        hooks[idx].hookStatus = MHOOK_HOOK_FAILED;

        hookCtx[idx].pSystemFunction = *hooks[idx].ppSystemFunction;
        hookCtx[idx].pHookFunction = hooks[idx].pHookFunction;
        hookCtx[idx].pTrampoline = NULL;
        hookCtx[idx].dwInstructionLength = 0;
        memset(&hookCtx[idx].patchdata, 0, sizeof(MHOOKS_PATCHDATA));

        ODPRINTF((L"mhooks: Mhook_SetHook: Started on the job: %p / %p", hookCtx[idx].pSystemFunction, hookCtx[idx].pHookFunction));

	// find the real functions (jump over jump tables, if any)
        hookCtx[idx].pSystemFunction = SkipJumps((PBYTE)hookCtx[idx].pSystemFunction);
        hookCtx[idx].pHookFunction = SkipJumps((PBYTE)hookCtx[idx].pHookFunction);

        if (FindSystemFunction(hookCtx, 0, idx, hookCtx[idx].pSystemFunction))
        {
            // Same system function found. Skip it.

            // It is not an error. 
            // This case is possible when two system functions from different DLLs are stubs and they are redirected to the one internal implementation.
            // We are going to hook first instance and skip other.

            ODPRINTF((L"mhooks: Mhook_SetHook: already hooked: %p", hookCtx[idx].pSystemFunction));

            hookCtx[idx].pTrampoline = NULL;
            hooks[idx].hookStatus = MHOOK_HOOK_SKIPPED;
        }
        else
        {
            ODPRINTF((L"mhooks: Mhook_SetHook: Started on the job: %p / %p", hookCtx[idx].pSystemFunction, hookCtx[idx].pHookFunction));

	// figure out the length of the overwrite zone
            hookCtx[idx].dwInstructionLength = DisassembleAndSkip(hookCtx[idx].pSystemFunction, MHOOK_JMPSIZE, &hookCtx[idx].patchdata);

            if (hookCtx[idx].dwInstructionLength >= MHOOK_JMPSIZE)
            {
                ODPRINTF((L"mhooks: Mhook_SetHook: disassembly signals %d bytes", hookCtx[idx].dwInstructionLength));

		// allocate a trampoline structure (TODO: it is pretty wasteful to get
		// VirtualAlloc to grab chunks of memory smaller than 100 bytes)
                hookCtx[idx].pTrampoline = TrampolineAlloc((PBYTE)hookCtx[idx].pSystemFunction, hookCtx[idx].patchdata.nLimitUp, hookCtx[idx].patchdata.nLimitDown);
            }
            else
            {
                // error - skip hook
                ODPRINTF((L"mhooks: disassembly signals %d bytes (unacceptable)", hookCtx[idx].dwInstructionLength));
            }
        }
    }

    if (true)
    {
        // make sure we're the most important thread in the process
        nOriginalPriority = GetThreadPriority(GetCurrentThread());
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    }

	void *freeCtx = nullptr;

    // suspend threads
    SuspendOtherThreads(hookCtx, hookCount, &freeCtx);

    if (true)
    {
        SetThreadPriority(GetCurrentThread(), nOriginalPriority);
    }

    // the next code is same to the Mhook_SetHook.  Differences are only in using hookCtx[i]
    for (int i = 0; i < hookCount; i++)
    {
        if (hookCtx[i].pTrampoline)
        {
            ODPRINTF((L"mhooks: Mhook_SetHook: allocated structure at %p", hookCtx[i].pTrampoline));
			DWORD dwOldProtectSystemFunction = 0;
			DWORD dwOldProtectTrampolineFunction = 0;
			// set the system function to PAGE_EXECUTE_READWRITE
            if (VirtualProtect(hookCtx[i].pSystemFunction, hookCtx[i].dwInstructionLength, PAGE_EXECUTE_READWRITE, &dwOldProtectSystemFunction))
            {
				ODPRINTF((L"mhooks: Mhook_SetHook: readwrite set on system function"));
				// mark our trampoline buffer to PAGE_EXECUTE_READWRITE
                if (VirtualProtect(hookCtx[i].pTrampoline, sizeof(MHOOKS_TRAMPOLINE), PAGE_EXECUTE_READWRITE, &dwOldProtectTrampolineFunction))
                {
					ODPRINTF((L"mhooks: Mhook_SetHook: readwrite set on trampoline structure"));

					// create our trampoline function
                    PBYTE pbCode = hookCtx[i].pTrampoline->codeTrampoline;

					// save original code..
                    for (DWORD k = 0; k < hookCtx[i].dwInstructionLength; k++) {
                        hookCtx[i].pTrampoline->codeUntouched[k] = pbCode[k] = ((PBYTE)hookCtx[i].pSystemFunction)[k];
					}
                    pbCode += hookCtx[i].dwInstructionLength;

					// plus a jump to the continuation in the original location
                    pbCode = EmitJump(pbCode, ((PBYTE)hookCtx[i].pSystemFunction) + hookCtx[i].dwInstructionLength);
					ODPRINTF((L"mhooks: Mhook_SetHook: updated the trampoline"));

					// fix up any IP-relative addressing in the code
                    FixupIPRelativeAddressing(hookCtx[i].pTrampoline->codeTrampoline, (PBYTE)hookCtx[i].pSystemFunction, &hookCtx[i].patchdata);

                    DWORD_PTR dwDistance = (PBYTE)hookCtx[i].pHookFunction < (PBYTE)hookCtx[i].pSystemFunction ?
                        (PBYTE)hookCtx[i].pSystemFunction - (PBYTE)hookCtx[i].pHookFunction : (PBYTE)hookCtx[i].pHookFunction - (PBYTE)hookCtx[i].pSystemFunction;
                    if (dwDistance > 0x7fff0000)
                    {
						// create a stub that jumps to the replacement function.
						// we need this because jumping from the API to the hook directly 
						// will be a long jump, which is 14 bytes on x64, and we want to 
						// avoid that - the API may or may not have room for such stuff. 
						// (remember, we only have 5 bytes guaranteed in the API.)
						// on the other hand we do have room, and the trampoline will always be
						// within +/- 2GB of the API, so we do the long jump in there. 
						// the API will jump to the "reverse trampoline" which
						// will jump to the user's hook code.
                        pbCode = hookCtx[i].pTrampoline->codeJumpToHookFunction;
                        pbCode = EmitJump(pbCode, (PBYTE)hookCtx[i].pHookFunction);
						ODPRINTF((L"mhooks: Mhook_SetHook: created reverse trampoline"));
                        FlushInstructionCache(GetCurrentProcess(), hookCtx[i].pTrampoline->codeJumpToHookFunction,
                            pbCode - hookCtx[i].pTrampoline->codeJumpToHookFunction);

						// update the API itself
                        pbCode = (PBYTE)hookCtx[i].pSystemFunction;
                        pbCode = EmitJump(pbCode, hookCtx[i].pTrampoline->codeJumpToHookFunction);
                    }
                    else
                    {
						// the jump will be at most 5 bytes so we can do it directly
						// update the API itself
                        pbCode = (PBYTE)hookCtx[i].pSystemFunction;
                        pbCode = EmitJump(pbCode, (PBYTE)hookCtx[i].pHookFunction);
					}

					// update data members
                    hookCtx[i].pTrampoline->cbOverwrittenCode = hookCtx[i].dwInstructionLength;
                    hookCtx[i].pTrampoline->pSystemFunction = (PBYTE)hookCtx[i].pSystemFunction;
                    hookCtx[i].pTrampoline->pHookFunction = (PBYTE)hookCtx[i].pHookFunction;

					// flush instruction cache and restore original protection
                    FlushInstructionCache(GetCurrentProcess(), hookCtx[i].pTrampoline->codeTrampoline, hookCtx[i].dwInstructionLength);
                    VirtualProtect(hookCtx[i].pTrampoline, sizeof(MHOOKS_TRAMPOLINE), dwOldProtectTrampolineFunction, &dwOldProtectTrampolineFunction);
                }
                else
                {
					ODPRINTF((L"mhooks: Mhook_SetHook: failed VirtualProtect 2: %d", gle()));
				}
				// flush instruction cache and restore original protection
                FlushInstructionCache(GetCurrentProcess(), hookCtx[i].pSystemFunction, hookCtx[i].dwInstructionLength);
                VirtualProtect(hookCtx[i].pSystemFunction, hookCtx[i].dwInstructionLength, dwOldProtectSystemFunction, &dwOldProtectSystemFunction);
            }
            else
            {
				ODPRINTF((L"mhooks: Mhook_SetHook: failed VirtualProtect 1: %d", gle()));
			}

            if (hookCtx[i].pTrampoline->pSystemFunction)
            {
				// this is what the application will use as the entry point
				// to the "original" unhooked function.
                *hooks[i].ppSystemFunction = hookCtx[i].pTrampoline->codeTrampoline;
				ODPRINTF((L"mhooks: Mhook_SetHook: Hooked the function!"));
            }
            else
            {
				// if we failed discard the trampoline (forcing VirtualFree)
                TrampolineFree(hookCtx[i].pTrampoline, TRUE);
                hookCtx[i].pTrampoline = NULL;
			}

            hooks[i].hookStatus = hookCtx[i].pTrampoline != NULL ? MHOOK_HOOK_INSTALLED : MHOOK_HOOK_FAILED;
        }
    }

    if (true)
    {
        // make sure we're the most important thread in the process
        nOriginalPriority = GetThreadPriority(GetCurrentThread());
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
		}

    // resume threads
    ResumeOtherThreads(freeCtx);

    if (true)
    {
        SetThreadPriority(GetCurrentThread(), nOriginalPriority);
	}

    free(hookCtx);

	LeaveCritSec();
}

BOOL Mhook_SetHook(PVOID *ppSystemFunction, PVOID pHookFunction)
{
    HOOK_INFO hook = { ppSystemFunction , pHookFunction, MHOOK_HOOK_FAILED, nullptr };
    Mhook_SetHookEx(&hook, 1);
    return hook.hookStatus != MHOOK_HOOK_FAILED;
}

//=========================================================================
BOOL Mhook_Unhook(PVOID *ppHookedFunction) {
	ODPRINTF((L"mhooks: Mhook_Unhook: %p", *ppHookedFunction));
	BOOL bRet = FALSE;
	EnterCritSec();
	// get the trampoline structure that corresponds to our function
	MHOOKS_TRAMPOLINE* pTrampoline = TrampolineGet((PBYTE)*ppHookedFunction);
	if (pTrampoline) {
        HOOK_CONTEXT ctx = { pTrampoline->pSystemFunction, ppHookedFunction, pTrampoline->cbOverwrittenCode, pTrampoline, { } };
		// make sure nobody's executing code where we're about to overwrite a few bytes
		void *freeCtx = nullptr;
		SuspendOtherThreads(&ctx, 1, &freeCtx);
		ODPRINTF((L"mhooks: Mhook_Unhook: found struct at %p", pTrampoline));
		DWORD dwOldProtectSystemFunction = 0;
		// make memory writable
		if (VirtualProtect(pTrampoline->pSystemFunction, pTrampoline->cbOverwrittenCode, PAGE_EXECUTE_READWRITE, &dwOldProtectSystemFunction)) {
			ODPRINTF((L"mhooks: Mhook_Unhook: readwrite set on system function"));
			PBYTE pbCode = (PBYTE)pTrampoline->pSystemFunction;
			for (DWORD i = 0; i<pTrampoline->cbOverwrittenCode; i++) {
				pbCode[i] = pTrampoline->codeUntouched[i];
			}
			// flush instruction cache and make memory unwritable
			FlushInstructionCache(GetCurrentProcess(), pTrampoline->pSystemFunction, pTrampoline->cbOverwrittenCode);
			VirtualProtect(pTrampoline->pSystemFunction, pTrampoline->cbOverwrittenCode, dwOldProtectSystemFunction, &dwOldProtectSystemFunction);
			// return the original function pointer
			*ppHookedFunction = pTrampoline->pSystemFunction;
			bRet = TRUE;
			ODPRINTF((L"mhooks: Mhook_Unhook: sysfunc: %p", *ppHookedFunction));
			// free the trampoline while not really discarding it from memory
			TrampolineFree(pTrampoline, FALSE);
			ODPRINTF((L"mhooks: Mhook_Unhook: unhook successful"));
		} else {
			ODPRINTF((L"mhooks: Mhook_Unhook: failed VirtualProtect 1: %d", gle()));
		}
		// make the other guys runnable
		ResumeOtherThreads(freeCtx);
	}
	LeaveCritSec();
	return bRet;
}

//=========================================================================
// For debug and unit tests only (MHOOK UNIT TEST = MHOOKUT)

void MHOOKUT_GetGlobalVars(MHOOKUT_GlobalVars * gv)
{
    gv->Hooks = g_pHooks;
    gv->HooksInUse = g_nHooksInUse;
    gv->PagesCache = g_pPagesCache;
    gv->PageSize = g_PageSize;
    gv->TramplinesInPage = g_TramplinesInPage;
}
